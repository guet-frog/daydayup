
2.16.6.内核启动的C语言阶段3
	本节讲解setup_arch函数中的machine查找的部分，初步分析了内核对机器码的定义和存储方式、比对方式、获取方式。
2.16.7.内核启动的C语言阶段4
	本节讲解setup_arch函数中对cmdline的处理，重点讲解了cmdline的传递方式、确认方式和其对内核的影响和意义。
2.16.8.内核启动的C语言阶段5
	本节讲解start_kernel函数中剩余部分函数调用直到rest_init的部分，并无太多重点细节。
2.16.9.内核启动的C语言阶段6
	本节重点讲解了rest_init函数中创建三个内核线程以及对这三个内核线程的介绍，本节课听完后就明白了操作系统最终的走向和归宿。
2.16.10.init进程详解1
	本节课从宏观上讲解了init进程的工作和主要作用，交代了操作系统在内核态和用户态下的切换过程，init进程如何一步步发展成为平时看到的操作系统。
2.16.11.init进程详解2
	本节对init进程的代码进行分析对比，重点是一些细节和对上节讲到的宏观理论的代码验证和支持。
2.16.12.cmdline常用参数
	本节补充讲解uboot给内核传参时常用的一些cmdline参数选项及其含义。
2.16.13.内核中架构相关代码简介	
	本节补充讲解内核源码中架构相关的代码部分，并非代码详解而是从宏观上讲述相关的文件夹和文件位置、作用介绍等。

	/*
		./Makefile
		arch/arm/kernel/vmlinux.lds.S
		arch/arm/kernel/head.S
		./init/main.c
		arch/arm/kernel/setup.c
	*/

2.16.1.3、Makefile分析
	(4)	Makefile中刚开始定义了kernel版本号		// 在模块化驱动安装时会需要用到

	(5)	make编译内核时传参		// make O=xxx指定编译目录

	(6)	kernel的顶层Makefile中两个重要变量: ARCH, CROSS_COMPILE

	// make O=/tmp/mykernel \
			ARCH=arm \
			CROSS_COMPILE=/usr/local/arm/arm-2009q3/bin/arm-none-linux-gnueabi-

2.16.1.4、链接脚本分析
	(1)	找到整个程序的entry		// ENTRY(stext)

	(2)	kernel的链接脚本: 编译vmlinux.lds.S生成vmlinux.lds	// 可能是为了使用条件编译的原因

	(6)	head.S kernel启动文件	// uboot中的start.S

2.16.2.3、内核运行的硬件条件	/* NOTE: comment */
	(1)	解压代码运行时先将zImage后段的内核解压开，然后再去调用运行真正的内核入口

	(2)	内核启动有一定的先决条件	/* uboot构建kernel启动环境 */

		// theKernel(0, machid, bd->bi_boot_params)
		// r0 = 0, r1 = macid, r2 = bd->bi_boot_params

2.16.2.4、内核启动要求的传参方式

2.16.3.内核启动的汇编阶段
	// 校验启动合法性、建立段式映射的页表并开启MMU
	// 构建C语言运行环境(复制data段, 清bss段)
	// b start_kernel

2.16.4.内核启动的C语言阶段1
	(1)	顺着代码执行路径抓全。这是我们的学习主线
	(2)	对照内核启动的打印信息进行分析

	(1)	分析uboot给kernel传参的影响和实现
	(2)	硬件初始化与驱动加载
	(3)	内核启动后的结局与归宿

2.16.5.内核启动的C语言阶段2
	(1)	smp()		// smp对称多处理器, 多核心CPU
	(2)	lockdep()	// 锁定依赖,是一个内核调试模块, 处理内核自旋锁死锁相关问题
	(3)	cgroup()	// control group, 内核提供的一种来处理进程组的技术

2.16.5.2、打印内核版本信息
	(1) printk()		// 打印级别设置
	(6)	linux_banner	// 宏在include/generated/

2.16.6.内核启动的C语言阶段3
2.16.6.1、setup_arch()
(2)实际上这个函数是用来//确定我们当前内核的机器（arch、machine）的。
	我们的linux内核会支持一种CPU的运行，CPU+开发板就确定了一个硬件平台，
	然后我们当前配置的内核就在这个平台上可以运行。之前说过的机器码就是给这个硬件平台一个固定的编码，
	以表征这个平台。
(3)当前内核支持的机器码以及硬件平台相关的一些定义都在这个函数中处理。

	// 

2.16.6.2、Machine查找
(1)setup_processor函数用来查找CPU信息，可以结合串口打印的信息来分析。
(2)setup_machine函数的传参是机器码编号，
	machine_arch_type符号在include/generated/mach-types.h的32039-32050行定义了。
	经过分析后确定这个传参值就是2456.
(3)函数的作用是通过传入的机器码编号，/*找到对应这个机器码的machine_desc描述符，并且返回这个描述符的指针。*/(其他地方已经构建好)
(4)其实真正干活的函数是lookup_machine_type，找这个函数发现在head-common.S中，真正干活的函数是__lookup_machine_type
	/* 如何查找取决于如何存放 */
	/* 链接时将所有具有相同段属性的段链接到一块 */

(5)__lookup_machine_type函数的工作原理：内核在建立的时候就把各种CPU架构的信息组织成一个一个的machine_desc结构体实例，
	然后都给一个段属性.arch.info.init，链接的时候会保证这些描述符会被连接在一起。
	__lookup_machine_type就去那个那些描述符所在处依次挨个遍历各个描述符，比对看机器码哪个相同。
	
	/* adr r3, 4b */		// 4是符号

2.16.7.内核启动的C语言阶段4
2.16.6.3、setup_arch函数进行了基本的cmdline处理
(1)这里说的cmdline就是指的uboot给kernel传参时传递的命令行启动参数，也就是uboot的bootargs。
(2)有几个相关的变量需要注意：
default_command_line：看名字是默认的命令行参数，实际是一个全局变量字符数组，这个字符数组可以用来存东西。
CONFIG_CMDLINE：在.config文件中定义的（可以在make menuconfig中去更改设置），这个表示内核的一个默认的命令行参数。
(3)内核对cmdline的处理思路是：内核中自己维护了一个默认的cmdline（就是.config中配置的这一个），然后uboot还可以通过tag给kernel再传递一个cmdline。如果uboot给内核传cmdline成功则内核会优先使用uboot传递的这一个；如果uboot没有给内核传cmdline或者传参失败，则内核会使用自己默认的这个cmdline。以上说的这个处理思路就是在setup_arch函数中实现的。

	/* NOTE: CONFIG_XXX 注意CONFIG开头的宏 .config */

2.6.6.4、实验验证内核的cmdline确定
(1)验证思路：首先给内核配置时配置一个基本的cmdline，然后在uboot启动内核时给uboot设置一个bootargs，然后启动内核看打印出来的cmdline和uboot传参时是否一样。
(2)在uboot中去掉bootargs，然后再次启动内核看打印出来的cmdline是否和内核中设置的默认的cmdline一样。

注意：uboot给内核传递的cmdline非常重要，会影响内核的运行，所以要谨慎。有时候内核启动有问题，可以分析下是不是uboot的bootargs设置不对。

注意：这个传参在这里确定出来之后，还没完。后面还会对这个传参进行解析。解析之后cmdline中的每一个设置项都会对内核启动有影响。
思考：内核为什么要这样设计？


2.16.8.内核启动的C语言阶段5
2.16.8.1、setup_command_line
(1)也是在处理和命令行参数cmdline有关的任务。
2.16.8.2、parse_early_param&parse_args
(1)解析cmdline传参和其他传参
(2)这里的解析意思是把cmdline的细节设置信息给解析出来。譬如cmdline：console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3，则解析出的内容就是就是一个字符串数组，数组中依次存放了一个设置项目信息。
console=ttySAC2,115200  一个
root=/dev/mmcblk0p2 rw  一个
init=/linuxrc 			一个
rootfstype=ext3			一个
(3)这里只是进行了解析，并没有去处理。也就是说只是把长字符串解析成了短字符串，最多和内核里控制这个相应功能的变量挂钩了，但是并没有去执行。执行的代码在各自模块初始化的代码部分。

2.16.8.3、杂碎
(1)trap_init					设置异常向量表
(2)mm_init						内存管理模块初始化
(3)sched_init					内核调度系统初始化
(4)early_irq_init&init_IRQ		中断初始化
(5)console_init					控制台初始化
总结：start_kernel函数中调用了很多的xx_init函数，全都是内核工作需要的模块的初始化函数。这些初始化之后内核就具有了一个基本的可以工作的条件了。
如果把内核比喻成一个复杂机器，那么start_kernel函数就是把这个机器的众多零部件组装在一起形成这个机器，让他具有可以工作的基本条件。

2.16.8.4、rest_init
(1)这个函数之前内核的基本组装已经完成。
(2)剩下的一些工作就比较重要了，放在了一个单独的函数中，叫rest_init。

总结：start_kernel函数做的主要工作：打印了一些信息、内核工作需要的模块的初始化被依次调用（譬如内存管理、调度系统、异常处理・・・）、我们需要重点了解的就是setup_arch中做的2件事情：机器码架构的查找并且执行架构相关的硬件的初始化、uboot给内核的传参cmdline。


2.16.9.内核启动的C语言阶段6
2.16.9.1、操作系统去哪了
(1)rest_init中调用kernel_thread函数启动了2个内核线程，分别是：kernel_init和kthreadd
(2)调用schedule函数开启了内核的调度系统，从此linux系统开始转起来了。
(3)rest_init最终调用cpu_idle函数结束了整个内核的启动。也就是说linux内核最终结束了一个函数cpu_idle。这个函数里面肯定是死循环。
(4)简单来说，linux内核最终的状态是：有事干的时候去执行有意义的工作（执行各个进程任务），实在没活干的时候就去死循环（实际上死循环也可以看成是一个任务）。
(5)之前已经启动了内核调度系统，调度系统会负责考评系统中所有的进程，这些进程里面只有有哪个需要被运行，调度系统就会终止cpu_idle死循环进程（空闲进程）转而去执行有意义的干活的进程。这样操作系统就转起来了。

2.16.9.2、什么是内核线程
(1)进程和线程。简单来理解，一个运行的程序就是一个进程。所以进程就是任务、进程就是一个独立的程序。独立的意思就是这个程序和别的程序是分开的，这个程序可以被内核单独调用执行或者暂停。
(2)在linux系统中，线程和进程非常相似，几乎可以看成是一样的。实际上我们当前讲课用到的进程和线程的概念就是一样的。
(3)进程/线程就是一个独立的程序。应用层运行一个程序就构成一个用户进程/线程，那么内核中运行一个函数（函数其实就是一个程序）就构成了一个内核进程/线程。
(4)所以我们kernel_thead函数运行一个函数，其实就是把这个函数变成了一个内核线程去运行起来，然后他可以被内核调度系统去调度。说白了就是去调度器注册了一下，以后人家调度的时候会考虑你。

2.16.9.3、进程0、进程1、进程2
(1)截至目前为止，我们一共涉及到3个内核进程/线程。
(2)操作系统是用一个数字来表示/记录一个进程/线程的，这个数字就被称为这个进程的进程号。这个号码是从0开始分配的。因此这里涉及到的三个进程分别是linux系统的进程0、进程1、进程2.
(3)在linux命令行下，使用ps命令可以查看当前linux系统中运行的进程情况。
(4)我们在ubuntu下ps -aux可以看到当前系统运行的所有进程，可以看出进程号是从1开始的。为什么不从0开始，因为进程0不是一个用户进程，而属于内核进程。
(5)三个进程
进程0：进程0其实就是刚才讲过的idle进程，叫空闲进程，也就是死循环。
进程1：kernel_init函数就是进程1，这个进程被称为init进程。
进程2：kthreadd函数就是进程2，这个进程是linux内核的守护进程。这个进程是用来保证linux内核自己本身能正常工作的。

总结1：本节课的重点在于理解linux内核启动后达到的一个稳定状态。注意去对比内核启动后的稳定状态和uboot启动后的稳定状态的区别。
总结2：本节课的第二个重点就是初步理解进程/线程的概念。
总结3：你得明白每个进程有个进程号，进程号从0开始依次分配的。明白进程0是idle进程（idle进程是干嘛的）；进程2是ktheadd进程（基本明白干嘛的就行）
总结4：分析到此，发现后续的料都在进程1.所以后面课程会重点从进程1出发，分析之后发生的事情。


// man 1 ps

2.16.10.init进程详解1
2.16.10.1、init进程完成了从内核态向用户态的转变
(1)一个进程2种状态。init进程刚开始运行的时候是内核态，它属于一个内核线程，然后他自己运行了一个用户态下面的程序后把自己强行转成了用户态。因为init进程自身完成了从内核态到用户态的过度，因此后续的其他进程都可以工作在用户态下面了。
(2)内核态下做了什么？重点就做了一件事情，就是挂载根文件系统并试图找到用户态下的那个init程序。init进程要把自己转成用户态就必须运行一个用户态的应用程序（这个应用程序名字一般也叫init），要运行这个应用程序就必须得找到这个应用程序，要找到它就必须得挂载根文件系统，因为所有的应用程序都在文件系统中。
内核源代码中的所有函数都是内核态下面的，执行任何一个都不能脱离内核态。应用程序必须不属于内核源代码，这样才能保证自己是用户态。也就是说我们这里执行的这个init程序和内核不在一起，他是另外提供的。提供这个init程序的那个人就是根文件系统。

	// init进程是在用户态下编译得到

(3)用户态下做了什么？init进程大部分有意义的工作都是在用户态下进行的。init进程对我们操作系统的意义在于：其他所有的用户进程都直接或者间接派生自init进程。

(4)如何从内核态跳跃到用户态？还能回来不？
init进程在内核态下面时，通过一个函数kernel_execve来执行一个用户空间编译连接的应用程序就跳跃到用户态了。注意这个跳跃过程中进程号是没有改变的，所以一直是进程1.这个跳跃过程是单向的，也就是说一旦执行了init程序转到了用户态下整个操作系统就算真正的运转起来了，以后只能在用户态下工作了，用户态下想要进入内核态只有走API这一条路了。

2.16.10.2、init进程构建了用户交互界面
(1)init进程是其他用户进程的老祖宗。linux系统中一个进程的创建是通过其父进程创建出来的。根据这个理论只要有一个父进程就能生出一堆子孙进程了。
(2)init启动了login进程、命令行进程、shell进程
(3)shell进程启动了其他用户进程。命令行和shell一旦工作了，用户就可以在命令行下通过./xx的方式来执行其他应用程序，每一个应用程序的运行就是一个进程。

总结：本节的主要目的是让大家认识到init进程如何一步步发展成为我们平时看到的那种操作系统的样子。


2.16.11.init进程详解2
2.16.11.1、打开控制台
(1)linux系统中每个进程都有自己的一个文件描述符表，表中存储的是本进程打开的文件。
(2)linux系统中有一个设计理念：一切届是文件。所以设备也是以文件的方式来访问的。我们要访问一个设备，就要去打开这个设备对应的文件描述符。譬如/dev/fb0这个设备文件就代表LCD显示器设备，/dev/buzzer代表蜂鸣器设备，/dev/console代表控制台设备。
(3)这里我们打开了/dev/console文件，并且复制了2次文件描述符，一共得到了3个文件描述符。这三个文件描述符分别是0、1、2.这三个文件描述符就是所谓的：标准输入、标准输出、标准错误。
(4)进程1打开了三个标准输出输出错误文件，因此后续的进程1衍生出来的所有的进程默认都具有这3个三件描述符。

2.16.11.2、挂载根文件系统
(1)prepare_namespace函数中挂载根文件系统
(2)根文件系统在哪里？根文件系统的文件系统类型是什么？ uboot通过传参来告诉内核这些信息。
uboot传参中的root=/dev/mmcblk0p2 rw 这一句就是告诉内核根文件系统在哪里
uboot传参中的rootfstype=ext3这一句就是告诉内核rootfs的类型。
(3)如果内核挂载根文件系统成功，则会打印出：VFS: Mounted root (ext3 filesystem) on device 179:2.
如果挂载根文件系统失败，则会打印：No filesystem could mount root, tried:  yaffs2
(4)如果内核启动时挂载rootfs失败，则后面肯定没法执行了，肯定会死。内核中设置了启动失败休息5s自动重启的机制，因此这里会自动重启，所以有时候大家会看到反复重启的情况。
(5)如果挂载rootfs失败，可能的原因有：
	最常见的错误就是uboot的bootargs设置不对。
	rootfs烧录失败（fastboot烧录不容易出错，以前是手工烧录很容易出错）
	rootfs本身制作失败的。（尤其是自己做的rootfs，或者别人给的第一次用）

2.16.11.3、执行用户态下的进程1程序
(1)上面一旦挂载rootfs成功，则进入rootfs中寻找应用程序的init程序，这个程序就是用户空间的进程1.找到后用run_init_process去执行他
(2)我们如果确定init程序是谁？方法是：
先从uboot传参cmdline中看有没有指定，如果有指定先执行cmdline中指定的程序。cmdline中的init=/linuxrc这个就是指定rootfs中哪个程序是init程序。这里的指定方式就表示我们rootfs的根目录下面有个名字叫linuxrc的程序，这个程序就是init程序。
如果uboot传参cmdline中没有init=xx或者cmdline中指定的这个xx执行失败，还有备用方案。第一备用：/sbin/init，第二备用：/etc/init，第三备用：/bin/init，第四备用：/bin/sh。
如果以上都不成功，则认命了，死了。


2.16.12.cmdline常用参数
2.16.12.1、格式简介
(1)格式就是由很多个项目用空格隔开依次排列，每个项目中都是项目名=项目值
(2)整个cmdline会被内核启动时解析，解析成一个一个的项目名=项目值的字符串。这些字符串又会被再次解析从而影响启动过程。
2.16.12.2、root=
(1)这个是用来指定根文件系统在哪里的
(2)一般格式是root=/dev/xxx（一般如果是nandflash上则/dev/mtdblock2，如果是inand/sd的话则/dev/mmcblk0p2）
(3)如果是nfs的rootfs，则root=/dev/nfs。

2.16.12.3、rootfstype=
(1)根文件系统的文件系统类型，一般是jffs2、yaffs2、ext3、ubi
2.16.12.4、console=
(1)控制台信息声明，譬如console=/dev/ttySAC0,115200表示控制台使用串口0，波特率是115200.
(2)正常情况下，内核启动的时候会根据console=这个项目来初始化硬件，并且重定位console到具体的一个串口上，所以这里的传参会影响后续是否能从串口终端上接收到内核的信息。

2.16.12.5、mem=
(1)mem=用来告诉内核当前系统的内存有多少

2.16.12.6、init=
(1)init=用来指定进程1的程序pathname，一般都是init=/linuxrc

2.16.12.7、常见cmdline介绍
(1)console=ttySAC2,115200 root=/dev/mmcblk0p2 rw init=/linuxrc rootfstype=ext3
第一种这种方式对应rootfs在SD/iNand/Nand/Nor等物理存储器上。这种对应产品正式出货工作时的情况。

(2)root=/dev/nfs nfsroot=192.168.1.141:/root/s3c2440/build_rootfs/aston_rootfs ip=192.168.1.10:192.168.1.141:192.168.1.1:255.255.255.0::eth0:off  init=/linuxrc console=ttySAC0,115200 
第二种这种方式对应rootfs在nfs上，这种对应我们实验室开发产品做调试的时候。


2.16.13.内核中架构相关代码简介
2.16.13.1、内核代码基本分为3块
(1)arch。		本目录下全是cpu架构有关的代码
(2)drivers		本目录下全是硬件的驱动
(3)其他			相同点是这些代码都和硬件无关，因此系统移植和驱动开发的时候这些代码几乎都是不用关注的。

2.16.13.2、架构相关的常用目录名及含义
(1)mach。（mach就是machine architecture）。arch/arm目录下的一个mach-xx目录就表示一类machine的定义，这类machine的共同点是都用xx这个cpu来做主芯片。（譬如mach-s5pv210这个文件夹里面都是s5pv210这个主芯片的开发板machine）；mach-xx目录里面的一个mach-yy.c文件中定义了一个开发板（一个开发板对应一个机器码），这个是可以被扩展的。
(2)plat（plat是platform的缩写，含义是平台）plat在这里可以理解为SoC，也就是说这个plat目录下都是SoC里面的一些硬件（内部外设）相关的一些代码。
在内核中把SoC内部外设相关的硬件操作代码就叫做平台设备驱动。
(3)include。这个include目录中的所有代码都是架构相关的头文件。（linux内核通用的头文件在内核源码树根目录下的include目录里）

2.16.13.3、补充
(1)内核中的文件结构很庞大、很凌乱（不同版本的内核可能一个文件存放的位置是不同的），会给我们初学者带来一定的困扰。
(2)头文件目录include有好几个，譬如：
	kernel/include		内核通用头文件
	kernel/arch/arm/include		架构相关的头文件
		kernel/arch/arm/include/asm
			kernel\arch\arm\include\asm\mach
	kernel\arch\arm\mach-s5pv210\include\mach
	kernel\arch\arm\plat-s5p\include\plat
(3)内核中包含头文件时有一些格式

#include <linux/kernel.h>		kernel/include/linux/kernel.h
#include <asm/mach/arch.h>		kernel/arch/arm/include/asm/mach/arch.h
#include <asm/setup.h>			kernel\arch\arm\include\asm/setup.h
#include <plat/s5pv210.h>		kernel\arch\arm\plat-s5p\include\plat/s5pv210.h

(4)有些同名的头文件是有包含关系的，有时候我们需要包含某个头文件时可能并不是直接包含他，而是包含一个包含了他的头文件。













